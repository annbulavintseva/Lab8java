# Національний технічний університет України

## "Київський політехнічний інститут імені Ігоря Сікорського"

### Булавінцева Анна ТЗ-22

Лабораторна робота №8

### 1. Чим інтерфейс Setвідрізняється від інтерфейсівCollection та List?
Collection — це базовий інтерфейс, який визначає загальні операції для всіх колекцій в Java, такі як додавання, видалення, перевірка наявності елементів тощо. Це надінтерфейс для списків, множин та черг.

List — підтип інтерфейсу Collection, що представляє впорядковану колекцію елементів, в якій елементи зберігаються у порядку додавання і можуть бути доступні за індексом. List дозволяє зберігати дублікати елементів.

Set — також підтип Collection, але це колекція, яка не дозволяє дублікати елементів. Вона не зберігає порядок елементів, якщо конкретна реалізація (наприклад, TreeSet) не підтримує сортування.

Set відрізняється від List тим, що не дозволяє дублікати, а від Collection — більш спеціалізоване, оскільки визначає властивості множин.

### 2. HashSet відрізняється від TreeSet?
HashSet:
Базується на хеш-таблиці.
Елементи не зберігають порядку (не впорядковані).
Швидкість операцій додавання, видалення та перевірки наявності елементів — O(1) (в середньому).
Немає гарантій щодо порядку елементів.

TreeSet:
Базується на дереві пошуку (звичайно червоно-чорне дерево).
Елементи зберігаються у відсортованому порядку.
Операції додавання, видалення та перевірки наявності елементів займають O(logn).
Підтримує сортування елементів.

Вибір між ними:
HashSet кращий для швидкої роботи, коли порядок елементів не важливий. TreeSet підходить, коли необхідно зберігати елементи в упорядкованому вигляді.

### 3. Що таке хешування, хеш, хеш-код, хеш-функція?
Хешування — це процес перетворення вхідних даних (наприклад, рядків) в числове значення (хеш) за допомогою хеш-функції.
Хеш — це результат роботи хеш-функції, числове значення, яке представляє об'єкт.
Хеш-код — це ціле число, яке використовується для швидкого доступу до об'єктів у хеш-таблицях (наприклад, в HashMap або HashSet).
Хеш-функція — це функція, яка приймає вхідні дані і генерує з них хеш-код.

### 4. Яким вимогам має відповідати коректна хеш-функція?
Коректна хеш-функція має відповідати наступним вимогам:
Сумісність: Якщо два об'єкти рівні (метод equals() повертає true), то їх хеш-коди мають бути однаковими.
Унікальність: Хеш-функція повинна максимально уникати колізій (коли два різні об'єкти мають однаковий хеш-код).
Швидкість: Хеш-функція повинна бути швидкою і ефективною.

### 5. Які властивості притаманні хорошій хеш-функції?
Розподіл хешів: Хеш-функція повинна забезпечувати рівномірний розподіл хешів, щоб уникнути великої кількості колізій.
Малий шанс колізій: Повинна мінімізувати ймовірність того, що різні об'єкти матимуть однакові хеш-коди.
Однозначність: Якщо два об'єкти рівні (метод equals()), їх хеш-коди повинні бути однаковими.

### 6. Якими критеріям мають відповідати об’єкти для того, щоб посилання на них можна було зберігати у HashSet?
Для того, щоб об'єкти могли зберігатись у HashSet, вони повинні відповідати таким вимогам:
Правильна реалізація методу hashCode(): Для об'єктів має бути коректно реалізований метод hashCode(), що генерує унікальні хеш-коди для різних об'єктів.
Правильна реалізація методу equals(): Оскільки HashSet не дозволяє дублікати, потрібно також правильно реалізувати метод equals(), який порівнює два об'єкти.
Об'єкти повинні бути немутабельними (незмінними) після того, як вони будуть вставлені в колекцію, оскільки зміна хеш-коду може привести до помилок.

### 7. Які є переваги/недоліки використання HashSetу порівнянні з TreeSet?
HashSet:
Переваги: Швидке виконання операцій додавання, видалення та перевірки наявності елементів.
Недоліки: Не зберігає порядок елементів.

TreeSet:
Переваги: Зберігає елементи в відсортованому порядку.
Недоліки: Більш повільні операції через складність O(logn) для додавання/видалення елементів.

Вибір: Якщо порядок елементів не важливий, використовуйте HashSet. Якщо важливо зберігати елементи в упорядкованому вигляді, використовуйте TreeSet.

### 8. Чим поняття sizeвідрізняється від capacity? Чи може sizeбути більший за capacity? Чи може capacity бути більший за size?Якщо так, то за яких умов?
Size — це поточна кількість елементів в колекції.
Capacity — це максимальна кількість елементів, які колекція може зберігати до того, як буде збільшена її ємність (наприклад, у ArrayList).
Можливі ситуації:
Capacity може бути більша за size: Якщо колекція ще не заповнена, її ємність буде більшою за кількість елементів.
Size не може бути більша за capacity: Це означає, що колекція перевищила свою ємність, і вона повинна автоматично розширити її (як це відбувається в ArrayList).

### 9. Що таке load factorта на що і як він впливає?
Load factor (коефіцієнт заповнення) визначає, коли колекція повинна збільшити свою ємність. Це значення зазвичай становить 0.75, що означає, що колекція збільшить свою ємність, коли вона досягне 75% від поточної ємності. 
Вищий коефіцієнт заповнення означає менше розширень, але більшу ймовірність колізій.

### 10. Що таке асоціативний масив? Чим ключ відрізняється від значення?
Асоціативний масив — це структура даних, що зберігає пари "ключ-значення", де кожному ключу ставиться у відповідність значення. Ключі в асоціативному масиві унікальні, а значення можуть бути дублюватися.
Ключ: Унікальний ідентифікатор для кожної пари.
Значення: Дані, які зберігаються і асоціюються з конкретним ключем.

### 11. Чи може в асоціативному масиві зберігатись кілька однакових ключів або однакових значень?
Ключі в асоціативному масиві повинні бути унікальними. Значення можуть бути однаковими для різних ключів.

### 12. До яких наслідків може привести зберігання неімутабельних об’єктів у HashSet, у HashMap в якості ключа та у HashMapв якості значення?
Якщо об'єкти, що зберігаються в HashSet або використовуються як ключі в HashMap, є неіммутабельними, це може призвести до низки проблем:
HashSet:
Якщо об'єкт змінюється після його додавання в HashSet, його хеш-код зміниться. Це може порушити правильну роботу хеш-таблиці, оскільки елемент буде переміщений в інше місце, але не буде знайдений при перевірці чи видаленні.
HashMap (як ключі):
Аналогічно HashSet, якщо ключі змінюються після їх додавання в HashMap, хеш-код зміниться. Це зробить пошук або видалення ключа неможливим, оскільки колекція використовує хеш-коди для доступу до значень.
HashMap (як значення):
Якщо значення не є імутабельними, це не призведе до проблем із хеш-кодом, оскільки хеш-код значення не використовується для зберігання в хеш-таблиці. Однак змінене значення може ускладнити логіку програми, якщо воно залежить від незмінних властивостей.

Для використання в HashSet та як ключі в HashMap, об'єкти повинні бути неімутабельними, щоб гарантувати стабільність хеш-кодів.

### 13.Чи можуть об’єкти без інтерфейсу Comparable зберігатись у TreeMap?
Ні, об'єкти без інтерфейсу Comparable не можуть бути використані в TreeMap без додаткового параметра компаратора. TreeMap використовує метод compareTo() або компаратор для порівняння елементів і підтримки сортування. 
Якщо об'єкти не реалізують Comparable і компаратор не заданий, буде викинута помилка під час виконання.

### 14. Чи можуть об’єкти без інтерфейсу Comparable зберігатись у HashMap? Чи взагалі впливає на щось наявність у об’єктів інтерфейсу Comparable при зберіганні у HashMap?
У HashMap наявність інтерфейсу Comparable не впливає на здатність зберігати об'єкти як ключі або значення, оскільки HashMap використовує hashCode() та equals() для пошуку ключів і значень, а не метод compareTo().
Тому об'єкти без Comparable можуть бути використані як ключі в HashMap без проблем. Єдиним обмеженням буде те, що при необхідності виконання операцій порівняння, такі об'єкти не зможуть використовувати стандартні механізми порівняння для сортування чи пошуку.
Загалом, наявність або відсутність інтерфейсу Comparable в об'єктах впливає тільки на колекції, які потребують сортування або порівняння (наприклад, TreeMap, TreeSet), але не на HashMap, де основними механізмами є hashCode() та equals().